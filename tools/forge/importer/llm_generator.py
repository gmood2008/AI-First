"""
LLM-based capability specification generator.
"""

import json
from typing import Union
from openai import OpenAI

from .types import (
    FunctionInfo, EndpointInfo, CapabilitySpec,
    MetaInfo, Contracts, Behavior, Interface,
    InterfaceParam, InterfaceOutput, SideEffectType
)


class LLMSpecGenerator:
    """Generate capability specifications using LLM"""
    
    def __init__(self, model: str = "gpt-4.1-mini"):
        """
        Initialize LLM generator.
        
        Args:
            model: OpenAI model to use (default: gpt-4.1-mini)
        """
        self.client = OpenAI()  # Uses OPENAI_API_KEY from environment
        self.model = model
    
    def generate_from_function(self, func_info: FunctionInfo, capability_id: str) -> CapabilitySpec:
        """
        Generate capability spec from Python function information.
        
        Args:
            func_info: Extracted function information
            capability_id: Desired capability ID (e.g., "tools.slack.send_message")
        
        Returns:
            Generated CapabilitySpec
        """
        prompt = self._build_function_prompt(func_info, capability_id)
        spec_dict = self._call_llm(prompt)
        return self._dict_to_spec(spec_dict, capability_id)
    
    def generate_from_endpoint(self, endpoint_info: EndpointInfo, capability_id: str) -> CapabilitySpec:
        """
        Generate capability spec from OpenAPI endpoint information.
        
        Args:
            endpoint_info: Extracted endpoint information
            capability_id: Desired capability ID (e.g., "api.users.create")
        
        Returns:
            Generated CapabilitySpec
        """
        prompt = self._build_endpoint_prompt(endpoint_info, capability_id)
        spec_dict = self._call_llm(prompt)
        return self._dict_to_spec(spec_dict, capability_id)
    
    def _build_function_prompt(self, func_info: FunctionInfo, capability_id: str) -> str:
        """Build prompt for function-based generation"""
        params_str = "\n".join([
            f"  - {p.name}: {p.type} (required={p.required}, sensitive={p.sensitive})"
            for p in func_info.parameters
        ])
        
        side_effects_str = ", ".join(func_info.side_effects) if func_info.side_effects else "none detected"
        
        return f"""You are a capability specification generator for AI-First Runtime.

Generate a complete capability specification in JSON format for the following Python function:

**Function Name:** {func_info.name}
**Capability ID:** {capability_id}
**Docstring:** {func_info.docstring or "No docstring provided"}
**Parameters:**
{params_str}
**Return Type:** {func_info.return_type}
**Detected Side Effects:** {side_effects_str}

**Requirements:**
1. Use the exact capability_id provided: "{capability_id}"
2. Generate clear, concise descriptions for all fields
3. Infer appropriate parameter descriptions from names and docstring
4. List ALL side effects (use detected ones + infer from function behavior)
5. If side effects include write operations (filesystem_write, network_write, system_exec, state_mutation), you MUST provide a specific undo_strategy (NOT "N/A" or "None")
6. Set requires_confirmation=true for destructive operations
7. Infer cost_model based on side effects (network ops = "network", file ops = "low_io", etc.)
8. Generate appropriate output fields based on return type and function behavior

**Valid side_effects values:**
- filesystem_read
- filesystem_write
- filesystem_delete
- network_read
- network_write
- system_exec
- state_mutation

**Valid cost_model values:**
- free
- low_io
- high_io
- network
- compute

**Output JSON Schema:**
{{
  "meta": {{
    "id": "{capability_id}",
    "version": "1.0.0",
    "author": "Auto-generated by Smart Importer",
    "description": "Clear description of what this capability does"
  }},
  "contracts": {{
    "side_effects": ["list", "of", "side_effects"],
    "requires_confirmation": true/false,
    "idempotent": true/false,
    "timeout_seconds": 30
  }},
  "behavior": {{
    "undo_strategy": "Specific description of how to undo this operation (REQUIRED for write ops)",
    "cost_model": "free|low_io|high_io|network|compute"
  }},
  "interface": {{
    "inputs": {{
      "param_name": {{
        "type": "string|integer|float|boolean|array|object",
        "description": "Clear parameter description",
        "required": true/false,
        "sensitive": true/false  // only if sensitive
      }}
    }},
    "outputs": {{
      "output_name": {{
        "type": "string|integer|float|boolean|array|object",
        "description": "Clear output description"
      }}
    }}
  }}
}}

**Critical Rules:**
1. If side_effects contains ANY of [filesystem_write, filesystem_delete, network_write, system_exec, state_mutation], undo_strategy MUST be a specific, actionable description (e.g., "Delete created file", "Restore file from backup", "Send DELETE request to /api/resource/{{id}}")
2. Generic undo strategies like "N/A", "None", "Cannot undo" are NOT acceptable for write operations
3. If truly cannot undo, explain why and suggest mitigation (e.g., "Cannot undo message send, but can delete message using API endpoint X")

Output ONLY valid JSON, no explanations or markdown.
"""
    
    def _build_endpoint_prompt(self, endpoint_info: EndpointInfo, capability_id: str) -> str:
        """Build prompt for endpoint-based generation"""
        params_str = "\n".join([
            f"  - {p.name}: {p.type} (required={p.required}, sensitive={p.sensitive})"
            for p in endpoint_info.parameters
        ])
        
        side_effects_str = ", ".join(endpoint_info.side_effects)
        
        return f"""You are a capability specification generator for AI-First Runtime.

Generate a complete capability specification in JSON format for the following API endpoint:

**Endpoint:** {endpoint_info.method} {endpoint_info.path}
**Capability ID:** {capability_id}
**Summary:** {endpoint_info.summary}
**Description:** {endpoint_info.description or "No description provided"}
**Parameters:**
{params_str}
**Detected Side Effects:** {side_effects_str}
**Tags:** {", ".join(endpoint_info.tags) if endpoint_info.tags else "none"}

**Requirements:**
1. Use the exact capability_id provided: "{capability_id}"
2. Generate clear, concise descriptions for all fields
3. Infer appropriate parameter descriptions from names and API documentation
4. List ALL side effects (use detected ones + infer from HTTP method)
5. If side effects include write operations (network_write, state_mutation), you MUST provide a specific undo_strategy
6. Set requires_confirmation=true for destructive operations (DELETE, some POST/PUT)
7. cost_model should be "network" for API calls
8. Generate appropriate output fields based on API response schema

**Valid side_effects values:**
- filesystem_read
- filesystem_write
- filesystem_delete
- network_read
- network_write
- system_exec
- state_mutation

**Valid cost_model values:**
- free
- low_io
- high_io
- network
- compute

**Output JSON Schema:**
{{
  "meta": {{
    "id": "{capability_id}",
    "version": "1.0.0",
    "author": "Auto-generated by Smart Importer",
    "description": "Clear description of what this capability does"
  }},
  "contracts": {{
    "side_effects": ["list", "of", "side_effects"],
    "requires_confirmation": true/false,
    "idempotent": true/false,
    "timeout_seconds": 30
  }},
  "behavior": {{
    "undo_strategy": "Specific description of how to undo this operation (REQUIRED for write ops)",
    "cost_model": "network"
  }},
  "interface": {{
    "inputs": {{
      "param_name": {{
        "type": "string|integer|float|boolean|array|object",
        "description": "Clear parameter description",
        "required": true/false,
        "sensitive": true/false  // only if sensitive
      }}
    }},
    "outputs": {{
      "output_name": {{
        "type": "string|integer|float|boolean|array|object",
        "description": "Clear output description"
      }}
    }}
  }}
}}

**Critical Rules:**
1. For POST/PUT/PATCH/DELETE operations, undo_strategy MUST be specific (e.g., "Send DELETE request to {endpoint_info.path}/{{id}}", "Send PUT request to restore previous state")
2. Generic undo strategies like "N/A", "None", "Cannot undo" are NOT acceptable for write operations
3. If truly cannot undo, explain why and suggest mitigation

Output ONLY valid JSON, no explanations or markdown.
"""
    
    def _call_llm(self, prompt: str) -> dict:
        """
        Call LLM to generate spec.
        
        Args:
            prompt: Generation prompt
        
        Returns:
            Generated spec as dictionary
        """
        response = self.client.chat.completions.create(
            model=self.model,
            messages=[
                {"role": "system", "content": "You are a capability specification generator. Output only valid JSON."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.3,  # Lower temperature for more consistent output
            response_format={"type": "json_object"}  # Ensure JSON output
        )
        
        content = response.choices[0].message.content
        
        try:
            return json.loads(content)
        except json.JSONDecodeError as e:
            raise ValueError(f"LLM returned invalid JSON: {e}\nContent: {content}")
    
    def _dict_to_spec(self, spec_dict: dict, capability_id: str) -> CapabilitySpec:
        """Convert dictionary to CapabilitySpec object"""
        # Validate structure
        required_keys = ["meta", "contracts", "behavior", "interface"]
        for key in required_keys:
            if key not in spec_dict:
                raise ValueError(f"Missing required key in generated spec: {key}")
        
        # Build MetaInfo
        meta = MetaInfo(
            id=spec_dict["meta"].get("id", capability_id),
            version=spec_dict["meta"].get("version", "1.0.0"),
            author=spec_dict["meta"].get("author", "Auto-generated"),
            description=spec_dict["meta"].get("description", ""),
        )
        
        # Build Contracts
        contracts = Contracts(
            side_effects=spec_dict["contracts"].get("side_effects", []),
            requires_confirmation=spec_dict["contracts"].get("requires_confirmation", False),
            idempotent=spec_dict["contracts"].get("idempotent", False),
            timeout_seconds=spec_dict["contracts"].get("timeout_seconds", 30),
        )
        
        # Build Behavior
        behavior = Behavior(
            undo_strategy=spec_dict["behavior"].get("undo_strategy", ""),
            cost_model=spec_dict["behavior"].get("cost_model", "free"),
        )
        
        # Build Interface
        inputs = {}
        for name, param_dict in spec_dict["interface"].get("inputs", {}).items():
            inputs[name] = InterfaceParam(
                type=param_dict.get("type", "string"),
                description=param_dict.get("description", ""),
                required=param_dict.get("required", True),
                sensitive=param_dict.get("sensitive", False),
                default=param_dict.get("default"),
            )
        
        outputs = {}
        for name, output_dict in spec_dict["interface"].get("outputs", {}).items():
            outputs[name] = InterfaceOutput(
                type=output_dict.get("type", "string"),
                description=output_dict.get("description", ""),
            )
        
        interface = Interface(inputs=inputs, outputs=outputs)
        
        return CapabilitySpec(
            meta=meta,
            contracts=contracts,
            behavior=behavior,
            interface=interface,
        )
