"""
Health Authority - The Judge

HealthAuthority evaluates signals and decides what should be proposed.

It MUST NOT:
- Mutate capability state
- Call LifecycleManager directly
- Touch the Registry

Output:
HealthAuthority outputs GovernanceProposal objects only.
"""

from enum import Enum
from typing import List, Dict, Optional
from datetime import datetime, timedelta
from dataclasses import dataclass
import json
from pathlib import Path
import sqlite3

from .signal_bus import SignalBus, SignalType, SignalSeverity
from .lifecycle_manager import LifecycleManager, CapabilityState


class ProposalType(str, Enum):
    """Types of governance proposals"""
    FIX = "FIX"                    # Fix reliability issues
    SPLIT = "SPLIT"                # Split into smaller capabilities
    UPGRADE_RISK = "UPGRADE_RISK"  # Increase risk level
    FREEZE = "FREEZE"              # Freeze capability


class ProposalStatus(str, Enum):
    """Proposal status"""
    PENDING = "PENDING"
    APPROVED = "APPROVED"
    REJECTED = "REJECTED"


@dataclass
class GovernanceProposal:
    """Governance proposal generated by Health Authority"""
    proposal_id: str
    capability_id: str
    proposal_type: ProposalType
    trigger_metrics: Dict[str, float]
    evidence_signal_ids: List[str]
    created_at: datetime
    status: ProposalStatus
    reason: str
    metadata: Dict
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for storage"""
        return {
            "proposal_id": self.proposal_id,
            "capability_id": self.capability_id,
            "proposal_type": self.proposal_type.value,
            "trigger_metrics": json.dumps(self.trigger_metrics),
            "evidence_signal_ids": json.dumps(self.evidence_signal_ids),
            "created_at": self.created_at.isoformat(),
            "status": self.status.value,
            "reason": self.reason,
            "metadata": json.dumps(self.metadata)
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> "GovernanceProposal":
        """Create from database record"""
        return cls(
            proposal_id=data["proposal_id"],
            capability_id=data["capability_id"],
            proposal_type=ProposalType(data["proposal_type"]),
            trigger_metrics=json.loads(data["trigger_metrics"]),
            evidence_signal_ids=json.loads(data["evidence_signal_ids"]),
            created_at=datetime.fromisoformat(data["created_at"]),
            status=ProposalStatus(data["status"]),
            reason=data["reason"],
            metadata=json.loads(data["metadata"] or "{}")
        )


class HealthAuthority:
    """
    Health Authority - The Judge
    
    Evaluates signals and generates governance proposals.
    This component is READ-ONLY with respect to capability state.
    """
    
    def __init__(
        self,
        signal_bus: SignalBus,
        lifecycle_manager: LifecycleManager,
        db_path: Optional[Path] = None
    ):
        """
        Initialize Health Authority.
        
        Args:
            signal_bus: SignalBus for reading signals
            lifecycle_manager: LifecycleManager for reading current states (read-only)
            db_path: Path to proposals database
        """
        self.signal_bus = signal_bus
        self.lifecycle_manager = lifecycle_manager
        
        if db_path is None:
            db_path = Path.home() / ".ai-first" / "governance_proposals.db"
        
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        
        self._init_database()
    
    def _init_database(self):
        """Initialize proposals database"""
        with sqlite3.connect(str(self.db_path)) as conn:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS governance_proposals (
                    proposal_id TEXT PRIMARY KEY,
                    capability_id TEXT NOT NULL,
                    proposal_type TEXT NOT NULL,
                    trigger_metrics TEXT NOT NULL,
                    evidence_signal_ids TEXT NOT NULL,
                    created_at TEXT NOT NULL,
                    status TEXT NOT NULL,
                    reason TEXT NOT NULL,
                    metadata TEXT NOT NULL
                )
            """)
            
            conn.execute("""
                CREATE INDEX IF NOT EXISTS idx_capability_id 
                ON governance_proposals(capability_id)
            """)
            
            conn.execute("""
                CREATE INDEX IF NOT EXISTS idx_status 
                ON governance_proposals(status)
            """)
            
            conn.commit()
    
    def compute_reliability_score(
        self,
        capability_id: str,
        window_hours: int = 24
    ) -> float:
        """
        Compute reliability score (0-100) based on success/failure signals.
        
        Args:
            capability_id: Capability to evaluate
            window_hours: Time window for evaluation
        
        Returns:
            Reliability score (0-100, where 100 is perfect)
        """
        end_time = datetime.now()
        start_time = end_time - timedelta(hours=window_hours)
        
        # Get execution signals
        success_signals = self.signal_bus.get_signals(
            capability_id=capability_id,
            signal_type=SignalType.EXECUTION_SUCCESS,
            start_time=start_time,
            end_time=end_time
        )
        
        failure_signals = self.signal_bus.get_signals(
            capability_id=capability_id,
            signal_type=SignalType.EXECUTION_FAILED,
            start_time=start_time,
            end_time=end_time
        )
        
        total = len(success_signals) + len(failure_signals)
        if total == 0:
            return 100.0  # No data = assume perfect
        
        success_count = len(success_signals)
        return (success_count / total) * 100.0
    
    def compute_human_intervention_rate(
        self,
        capability_id: str,
        window_hours: int = 24
    ) -> float:
        """
        Compute human intervention rate (0-100).
        
        Args:
            capability_id: Capability to evaluate
            window_hours: Time window for evaluation
        
        Returns:
            Human intervention rate (0-100)
        """
        end_time = datetime.now()
        start_time = end_time - timedelta(hours=window_hours)
        
        # Get human rejection signals
        human_rejections = self.signal_bus.get_signals(
            capability_id=capability_id,
            signal_type=SignalType.HUMAN_REJECTED,
            start_time=start_time,
            end_time=end_time
        )
        
        # Get all execution attempts
        all_executions = self.signal_bus.get_signals(
            capability_id=capability_id,
            start_time=start_time,
            end_time=end_time
        )
        
        total_attempts = len([s for s in all_executions if s.signal_type in [
            SignalType.EXECUTION_SUCCESS,
            SignalType.EXECUTION_FAILED,
            SignalType.HUMAN_REJECTED
        ]])
        
        if total_attempts == 0:
            return 0.0
        
        return (len(human_rejections) / total_attempts) * 100.0
    
    def count_rollbacks(
        self,
        capability_id: str,
        window_hours: int = 24
    ) -> int:
        """Count rollback signals in time window"""
        end_time = datetime.now()
        start_time = end_time - timedelta(hours=window_hours)
        
        rollback_signals = self.signal_bus.get_signals(
            capability_id=capability_id,
            signal_type=SignalType.ROLLBACK_TRIGGERED,
            start_time=start_time,
            end_time=end_time
        )
        
        return len(rollback_signals)
    
    def evaluate_and_propose(
        self,
        capability_id: str,
        window_hours: int = 24
    ) -> List[GovernanceProposal]:
        """
        Evaluate capability health and generate proposals.
        
        This is READ-ONLY - it only generates proposals, does not mutate state.
        
        Args:
            capability_id: Capability to evaluate
            window_hours: Time window for evaluation
        
        Returns:
            List of governance proposals
        """
        proposals = []
        
        # Compute metrics
        reliability = self.compute_reliability_score(capability_id, window_hours)
        human_intervention = self.compute_human_intervention_rate(capability_id, window_hours)
        rollback_count = self.count_rollbacks(capability_id, window_hours)
        
        # Get evidence signals
        end_time = datetime.now()
        start_time = end_time - timedelta(hours=window_hours)
        evidence_signals = self.signal_bus.get_signals(
            capability_id=capability_id,
            start_time=start_time,
            end_time=end_time
        )
        evidence_signal_ids = [s.signal_id for s in evidence_signals]
        
        trigger_metrics = {
            "reliability_score": reliability,
            "human_intervention_rate": human_intervention,
            "rollback_count": rollback_count
        }
        
        # Rule 1: Reliability < 80% → FIX
        if reliability < 80.0:
            proposal = GovernanceProposal(
                proposal_id=f"prop_{datetime.now().timestamp()}_{capability_id}",
                capability_id=capability_id,
                proposal_type=ProposalType.FIX,
                trigger_metrics=trigger_metrics,
                evidence_signal_ids=evidence_signal_ids,
                created_at=datetime.now(),
                status=ProposalStatus.PENDING,
                reason=f"Reliability score {reliability:.1f}% is below 80% threshold",
                metadata={"threshold": 80.0}
            )
            proposals.append(proposal)
        
        # Rule 2: Human intervention > 50% → SPLIT or UPGRADE_RISK
        if human_intervention > 50.0:
            # Choose SPLIT if reliability is also low, otherwise UPGRADE_RISK
            if reliability < 70.0:
                proposal_type = ProposalType.SPLIT
                reason = f"High human intervention ({human_intervention:.1f}%) and low reliability ({reliability:.1f}%)"
            else:
                proposal_type = ProposalType.UPGRADE_RISK
                reason = f"High human intervention rate ({human_intervention:.1f}%) suggests risk level may be too low"
            
            proposal = GovernanceProposal(
                proposal_id=f"prop_{datetime.now().timestamp()}_{capability_id}_intervention",
                capability_id=capability_id,
                proposal_type=proposal_type,
                trigger_metrics=trigger_metrics,
                evidence_signal_ids=evidence_signal_ids,
                created_at=datetime.now(),
                status=ProposalStatus.PENDING,
                reason=reason,
                metadata={"threshold": 50.0}
            )
            proposals.append(proposal)
        
        # Rule 3: Repeated rollbacks → FREEZE
        if rollback_count >= 3:
            proposal = GovernanceProposal(
                proposal_id=f"prop_{datetime.now().timestamp()}_{capability_id}_rollback",
                capability_id=capability_id,
                proposal_type=ProposalType.FREEZE,
                trigger_metrics=trigger_metrics,
                evidence_signal_ids=evidence_signal_ids,
                created_at=datetime.now(),
                status=ProposalStatus.PENDING,
                reason=f"{rollback_count} rollbacks in {window_hours} hours",
                metadata={"rollback_threshold": 3}
            )
            proposals.append(proposal)
        
        # Persist proposals
        for proposal in proposals:
            self._save_proposal(proposal)
        
        return proposals
    
    def _save_proposal(self, proposal: GovernanceProposal):
        """Save proposal to database"""
        with sqlite3.connect(str(self.db_path)) as conn:
            conn.execute("""
                INSERT OR REPLACE INTO governance_proposals
                (proposal_id, capability_id, proposal_type, trigger_metrics, evidence_signal_ids,
                 created_at, status, reason, metadata)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                proposal.proposal_id,
                proposal.capability_id,
                proposal.proposal_type.value,
                json.dumps(proposal.trigger_metrics),
                json.dumps(proposal.evidence_signal_ids),
                proposal.created_at.isoformat(),
                proposal.status.value,
                proposal.reason,
                json.dumps(proposal.metadata)
            ))
            conn.commit()
    
    def get_pending_proposals(self) -> List[GovernanceProposal]:
        """Get all pending proposals"""
        proposals = []
        with sqlite3.connect(str(self.db_path)) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.execute("""
                SELECT * FROM governance_proposals 
                WHERE status = ? 
                ORDER BY created_at DESC
            """, (ProposalStatus.PENDING.value,))
            
            for row in cursor:
                proposals.append(GovernanceProposal.from_dict(dict(row)))
        
        return proposals
    
    def update_proposal_status(
        self,
        proposal_id: str,
        status: ProposalStatus,
        reason: Optional[str] = None
    ):
        """
        Update proposal status (called by Console UI).
        
        This is still read-only with respect to capability state.
        The Console UI will call LifecycleManager separately.
        """
        with sqlite3.connect(str(self.db_path)) as conn:
            update_query = "UPDATE governance_proposals SET status = ?"
            params = [status.value]
            
            if reason:
                update_query += ", reason = ?"
                params.append(reason)
            
            update_query += " WHERE proposal_id = ?"
            params.append(proposal_id)
            
            conn.execute(update_query, params)
            conn.commit()
